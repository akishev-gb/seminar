# Инструкция по работе с Git

## Начальная работа с сиcтемой контроля версий

- *git --version* - **Команда для проверки версии Git**

- *git config --global user.name "Ваше имя английскими буквами"* - **например: Konstantin**

- *git config --global user.email* - **ваша почта@example.com**

- *git init* - __Инициализируем пустой репозиторий__

- *git status* - **Проверяем текущее состояние файла**

- *git add* - **Добавляем версионность файла**

- *git commit -m "Message"* - **Комманда для фиксации изменений в файлах**

- *git log* - **Вывод истории коммитов в хронологическом порядке**

![Например](log.jpg)

- *git diff* - **Вывод изменений на текущий момент по отношению к последнему коммиту**

- *git checkout (master либо хэш-номер коммита)* - **переход между изменениями либо возврат к текущему состоянию**

>**Отследить интересующие вас операции в списке изменений, можно по хэшу коммита, при помощи команды** 
~~~
*git show hash_commit*
~~~

>**если вдруг нам нужно переделать commit message и внести туда новый комментарий, можно написать следующую конструкцию** 
~~~
*git commit --amend -m 'Новый комментарий'*
~~~
__Больше информации здесь:__
<https://proglib.io/p/git-for-half-an-hour>

## Ветвление

Во время разработки новой функциональности считается хорошей практикой работать с копией оригинального проекта, которую называют веткой. Ветви имеют свою собственную историю и изолированные друг от друга изменения до тех пор, пока вы не решаете слить изменения вместе. Это происходит по набору причин:

- Уже рабочая, стабильная версия кода сохраняется.
- Различные новые функции могут разрабатываться параллельно разными программистами.
- Разработчики могут работать с собственными ветками без риска, что кодовая база поменяется из-за чужих изменений.
- В случае сомнений, различные реализации одной и той же идеи могут быть разработаны в разных ветках и затем сравниваться.

__Основная ветка в каждом репозитории называется master. Чтобы создать еще одну ветку, используем команду__ 
~~~
*git branch (branch_name)* 
~~~
__Это создаст новую ветку, пока что точную копию ветки master.__

__Для переключения между ветками используется комманда__ 
~~~
*git checkout (branch_name)*
~~~
__Для объедиинения веток нужно набрать из ветки, в которую мы хотим залить изменения комманду__ 
~~~
*git merge (имя ветки, которую хотим перенести)*
~~~
## Удаленные репозитории

__Репозиторий, хранящийся в облаке, на стороннем сервисе, специально созданном для работы с git имеет ряд преимуществ. Во-первых - это своего рода резервная копия вашего проекта, предоставляющая возможность безболезненной работы в команде. А еще в таком репозитории можно пользоваться дополнительными возможностями хостинга. К примеру -визуализацией истории или возможностью разрабатывать вашу программу непосредственно в веб-интерфейсе.__

# Клонирование

*Клонирование* - __это когда вы копируете удаленный репозиторий к себе на локальный ПК. Это то, с чего обычно начинается любой проект. При этом вы переносите себе все файлы и папки проекта, а также всю его историю с момента его создания. Чтобы склонировать проект, сперва, необходимо узнать где он расположен и скопировать ссылку на него.__

__Для клонирования удаленного репозитория используйте комманду:__
~~~
git clone <ссылка на удаленный репозиторий>
~~~

__Если вы сделали изменения в вашем удаленном репозитории, другие пользователи могут скачать изменения при помощи команды:__
~~~
git pull
~~~

__чтобы отправить изменения на сервер используйте комманду:__
~~~
git push
~~~
## Настройка .gitignore

В большинстве проектов есть файлы или целые директории, в которые мы не хотим (и, скорее всего, не захотим) коммитить. Мы можем удостовериться, что они случайно не попадут в git add -A при помощи файла .gitignore

1. Создайте вручную файл под названием .gitignore и сохраните его в директорию проекта.
2. Внутри файла перечислите названия файлов/папок, которые нужно игнорировать, каждый с новой строки.
3. Файл .gitignore должен быть добавлен, закоммичен и отправлен на сервер, как любой другой файл в проекте.

## Разрешение конфликтов при слиянии

__Конфликты регулярно возникают при слиянии ветвей или при отправке чужого кода. Иногда конфликты исправляются автоматически, но обычно с этим приходится разбираться вручную — решать, какой код остается, а какой нужно удалить.__

__Над разделителем ======= мы видим последний (HEAD) коммит, а под ним - конфликтующий. Таким образом, мы можем увидеть, чем они отличаются и решать, какая версия лучше. Или вовсе написать новую.__

__Многие разработчики предпочитают использовать для разрешения конфликтов клиенты с графическим интерфейсом. Для запуска нужно набрать__ 
~~~
*git mergetool*
~~~