# Репозиторий для пул реквестов

# Краткая инструкция для работы с СКВ GIT
____
## 1. Что такое GIT?
В отличие от других СКВ рабта GIT построена не на запоминании изменений файлов (храннеие данных как набора изменений относительно первоначальной версии файла), а на т.н. принципе снимка.  

Каждый раз, когда вы делаете коммит, то есть `сохраняете состояние своего проекта в Git`, система запоминает, как выглядит каждый файл в этот момент, и сохраняет ссылку на этот снимок. Для увеличения эффективности, если файлы не были изменены, Git не запоминает эти файлы вновь, а только создаёт ссылку на предыдущую версию идентичного файла, который уже сохранён. Git представляет свои данные как, скажем, `поток снимков`.

В Git для всего вычисляется хеш-сумма, и только потом происходит сохранение. В дальнейшем обращение к сохранённым объектам происходит по этой хеш-сумме. Это значит, что невозможно изменить содержимое файла или каталога так, чтобы Git не узнал об этом. Данная функциональность встроена в Git на низком уровне и является неотъемлемой частью его философии. Вы не потеряете информацию во время её передачи и не получите повреждённый файл без ведома Git.  

Хэш-сумма - это и есть 40 символов, определяющих название коммита

`У Git есть три основных состояния, в которых могут находиться ваши файлы: изменён (modified), индексирован (staged) и зафиксирован (committed)`:

К `изменённым` относятся файлы, которые поменялись, но ещё не были зафиксированы.

`Индексированный` — это изменённый файл в его текущей версии, отмеченный для включения в следующий коммит.

`Зафиксированный` значит, что файл уже сохранён в вашей локальной базе.

Мы подошли к трём основным секциям проекта Git: рабочая копия (**_working tree_**), область индексирования (**_staging area_**) и каталог Git (**_Git directory_**).

*Рабочая копия, область индексирования и каталог Git*

**Рабочая копия** является снимком одной версии проекта. Эти файлы извлекаются из сжатой базы данных в каталоге Git и помещаются на диск, для того чтобы их можно было использовать или редактировать.

**Область индексирования** — это файл, обычно находящийся в каталоге Git, в нём содержится информация о том, что попадёт в следующий коммит. Её техническое название на языке Git — «индекс», но фраза «область индексирования» также работает.

**Каталог Git** — это то место, где Git хранит метаданные и базу объектов вашего проекта. Это самая важная часть Git и это та часть, которая копируется при клонировании репозитория с другого компьютера.

**Базовый подход в работе с Git выглядит так**:

Изменяете файлы вашей рабочей копии.

Выборочно добавляете в индекс только те изменения, которые должны попасть в следующий коммит, добавляя тем самым снимки только этих изменений в индекс.

Когда вы делаете коммит, используются файлы из индекса как есть, и этот снимок сохраняется в ваш каталог Git.

Если определённая версия файла есть в каталоге Git, эта версия считается зафиксированной (committed). Если файл был изменён и добавлен в индекс, значит, он индексирован (staged). И если файл был изменён с момента последнего распаковывания из репозитория, но не был добавлен в индекс, он считается изменённым (modified).

## 2. Базовые команды GIT

+ **`Cоздание репозитория`**
> _**git init**_ - создание нового локального репозитория;  
_**git clone URL**_ - создание копии уже существующего git-репозитория.

+ **`Отслеживание и запись состояния файлов`**

Каждый файл в вашем рабочем каталоге может находиться в одном из двух состояний: под версионным контролем **(отслеживаемые)** и нет **(неотслеживаемые)**. 

***Отслеживаемые файлы*** — это те файлы, которые были в последнем снимке состояния проекта; они могут быть *неизменёнными*, *изменёнными* или *подготовленными к коммиту*. Если кратко, то отслеживаемые файлы — это те файлы, о которых знает Git.

***Неотслеживаемые файлы (Untracked files)*** — это всё остальное, любые файлы в вашем рабочем каталоге, которые не входили в ваш последний снимок состояния и не подготовлены к коммиту. 

> ***git status*** - определение, какие файлы в каком состоянии находятся;  
    >> исключение определенных файлов из отслеживания git осуществляется с помощью файлов .gitignor в которые вносятся типы и (или) имена игнорируемых файлов, примеры файлов .gitignor доступны [на сайте github](https://github.com/github/gitignore)  

>***git add file.name*** - включение файла под версионный контроль (включение в индекс, подготовка к комиту);  
***git diff*** - эта команда сравнивает содержимое вашего рабочего каталога с содержимым индекса. Результат показывает ещё не проиндексированные изменения;  
***git diff --staged*** - если вы хотите посмотреть, что вы проиндексировали и что войдёт в следующий коммит, вы можете выполнить git diff --staged. Эта команда сравнивает ваши проиндексированные изменения с последним коммитом;
***git commit -m "massege"*** - фиксация (комит) комит всех ихменений, включенных в индекс;  
***git commit -a -m "massege"*** - фиксирует все изменения файлов в рабочей области, минуя индекс (включает в комит все файлы, не трtбуя команды git add);  
***git rm file.name*** - удаление файла из индекса и из рабочего каталога;  
***git rm --cached file.name*** - удаление файла из индекса, с оставлением в рабочем каталоге (на жестком диске).

**`Неплохая шпаргалка для понимания механики работы git (транспорта данных)`**:
![шпаргалка по транспорту в git](https://beckettcircle.org/sources/show/show-git-diff-head1-of-file-not-touched-in-recent-commits.png)

+ ***`Пометка или "Тег"`*** 

Как и большинство VCSS, Git имеет возможность помечать определенные точки в истории репозитория как важные. Обычно люди используют эту функциональность для маркировки точек выпуска (v1.0, v2.0и так далее). 

Перечисление существующих тегов в Git просто. Просто введите git tag(с дополнительным -lили --list):

>git tag  
v1.0  
v2.0  

Эта команда перечисляет теги в алфавитном порядке; порядок, в котором они отображаются, не имеет реального значения.

Создание тегов
Git поддерживает два типа тегов: облегченные и аннотированные.

Легкий тег очень похож на ветку, которая не меняется — это просто указатель на определенный коммит.

Аннотированные теги, однако, хранятся как полные объекты в базе данных Git. Они имеют контрольную сумму; содержат имя теггера, адрес электронной почты и дату; имеют сообщение о тегировании; и могут быть подписаны и проверены с помощью GNU Privacy Guard (GPG). Обычно рекомендуется создавать аннотированные теги, чтобы иметь всю эту информацию; но если вам нужен временный тег или по какой-то причине вы не хотите хранить другую информацию, легкие теги также доступны.

`Аннотированные теги`

Создание аннотированного тега в Git очень просто. Самый простой способ-указать-a, когда вы запускаете tagкоманду:

>git tag -a v1.4 -m "my version 1.4"  
git tag  
v0.1  
v1.3  
v1.4  

`-m` Указывает сообщение тегирования, которое хранится вместе с тегом. Если вы не указали сообщение для аннотированного тега, Git запускает редактор, чтобы вы могли ввести его.

Вы можете увидеть данные тега вместе с фиксацией, которая была помечена с помощью git showкоманды:

> git show v1.4  
tag v1.4  
Tagger: Ben Straub <ben@straub.cc>  
Date:   Sat May 3 20:19:12 2014 -0700  
my version 1.4  
commit ca82a6dff817ec66f44342007202690a93763949  
Author: Scott Chacon <schacon@gee-mail.com>  
Date:   Mon Mar 17 21:52:11 2008 -0700



Это показывает информацию теггера, дату, когда фиксация была помечена, и сообщение аннотации перед отображением информации о фиксации.

`Легкие теги`

Еще один способ пометить коммиты-это легкий тег. Это в основном контрольная сумма фиксации, хранящаяся в файле — никакая другая информация не сохраняется. Чтобы создать легкий тег, не указывайте ни `-a` один из параметров `-s`, или `-m`, просто укажите имя тега:

> git tag v1.4-lw  
git tag  
v0.1  
v1.3  
v1.4  
v1.4-lw  
v1.5  

На этот раз, если вы запустите git showтег, вы не увидите дополнительную информацию о теге. Команда просто показывает коммит:

git show v1.4-lw
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <schacon@gee-mail.com>
Date:   Mon Mar 17 21:52:11 2008 -0700

Change version number

**`Пометка позже`**

Вы также можете пометить коммиты после того, как вы прошли мимо них. Предположим, ваша история фиксации выглядит следующим образом:

> `git log --pretty=oneline`
15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'  
a6b4c97498bd301d84096da251c98a07c7723e65 Create write support  
0d52aaab4479697da7686c15f77a3d64d9165190 One more thing  
6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'  
0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc Add commit function  
4682c3261057305bdd616e23b64b0857d832627b Add todo file  
166ae0c4d3f420721acbb115cc33848dfcc2121a Create write support  
9fceb02d0ae598e95dc970b74767f19372d61af8 Update rakefile  
964f16d36dfccde844893cac5b347e7b3d44abbc Commit the todo  
8a5cbc430f1a9c3d00faaeffd07798508422908a Update readme  

Теперь предположим, что вы забыли пометить проект в v1.2, который был в фиксации “Update rakefile”. Вы можете добавить его после факта. Чтобы пометить этот коммит, вы указываете контрольную сумму коммита (или ее часть) в конце команды:

>`git tag -a v1.2 9fceb02`  
Вы можете видеть, что вы отметили коммит:  
git tag  
v0.1  
v1.2  
v1.3  
v1.4  
v1.4-lw  
v1.5  
git show v1.2  
tag v1.2  
Tagger: Scott Chacon <schacon@gee-mail.com>  
Date:   Mon Feb 9 15:32:16 2009 -0800  
version 1.2  
commit 9fceb02d0ae598e95dc970b74767f19372d61af8  
Author: Magnus Chacon <mchacon@gee-mail.com>  
Date:   Sun Apr 27 20:43:35 2008 -0700  

 
* __`Псевдонимы в GIT`__

Git не выводит вашу команду автоматически, если вы вводите ее частично. Если вы не хотите вводить весь текст каждой из команд Git, вы можете легко настроить псевдоним для каждой команды с помощью git config. Вот несколько примеров, которые вы можете настроить:

>**git config --global alias.co checkout  
git config --global alias.br branch  
git config --global alias.ci commit  
git config --global alias.st status**  
+ **`Просмотр истории фиксаций`**  
После создания нескольких коммитов или клонирования репозитория с существующей историей фиксаций вам, вероятно, захочется оглянуться назад и посмотреть, что произошло. Самый простой и мощный инструмент для этого `-git log` команда.

По умолчанию, без аргументов, git logперечислены коммиты, сделанные в этом репозитории в обратном хронологическом порядке; то есть самые последние коммиты отображаются первыми. Как вы можете видеть, эта команда перечисляет каждую фиксацию с контрольной суммой SHA-1, именем автора и электронной почтой, датой записи и сообщением о фиксации.

Огромное количество и разнообразие опций для git logкоманды доступны, чтобы показать вам именно то, что вы ищете. Здесь мы покажем вам некоторые из самых популярных.

`-p` - Показать патч, введенный с каждой фиксацией.

`--stat` - Показать статистику по файлам, измененным в каждой фиксации.

`--shortstat` - Отображать только строку измененные/вставки/удаления из команды --stat.

`--name-only` - Показать список файлов, измененных после фиксации информации.

`--name-status` - Показать список файлов, затронутых добавленной/измененной/удаленной информацией.

`--abbrev-commit` - Показывать только первые несколько символов контрольной суммы SHA-1 вместо всех 40.

`--relative-date` - Отображение даты в относительном формате (например, “2 недели назад”) вместо использования полного формата даты.

`--graph` - Рядом с выводом журнала отобразите ASCII-график истории ветвей и слияний.

`--pretty` - Показать коммиты в альтернативном формате. Значения параметров включают oneline, short, full, fuller и format (где вы указываете свой собственный формат).

`--oneline` - Сокращение для --pretty=oneline --abbrev-commitиспользуется вместе.
##      2. ***`Ветвление`***

Существует всего несколько команд, которые реализуют большую часть функций ветвления и слияния в Git.

`git branch`
git branch Команда на самом деле является чем-то вроде инструмента управления филиалами. Он может перечислять ветви, которые у вас есть, создавать новую ветвь, удалять ветви и переименовывать ветви.

Большая часть ветвления Git посвящена branch команде и используется на протяжении всей главы. Сначала мы вводим его при создании новой ветви, и мы проходим через большинство других его функций (перечисление и удаление) в управлении ветвями.

В ветвях отслеживания мы используем git branch -uопцию для настройки ветви отслеживания.

Наконец, мы рассмотрим некоторые из того, что он делает в фоновом режиме в ссылках Git.

`git checkout`
git checkout Команда используется для переключения ветвей и проверки содержимого в вашем рабочем каталоге.

Мы впервые сталкиваемся с командой при переключении ветвей вместе с git branch командой.

Мы видим, как использовать его, чтобы начать отслеживать ветви с --track флагом в отслеживании ветвей.

Мы используем его для повторного введения конфликтов файлов --conflict=diff3 при проверке конфликтов.


`git merge`
git merge Инструмент используется для объединения одной или нескольких ветвей в ветку, которую вы проверили. Затем он приведет текущую ветвь к результату слияния.


`git mergetool`
git mergetoolКоманда просто запускает внешний помощник слияния в случае, если у вас возникли проблемы со слиянием в Git.

Мы быстро упоминаем об этом в основных конфликтах слияний и подробно рассказываем о том, как реализовать свой собственный инструмент внешнего слияния во внешних инструментах слияния и различия.

git log
git logКоманда используется для отображения достижимой записанной истории проекта с самого последнего снимка фиксации в обратном направлении. По умолчанию он будет показывать только историю ветви, в которой вы находитесь в данный момент, но может иметь разные или даже несколько головок или ветвей, из которых можно перемещаться. Он также часто используется, чтобы показать различия между двумя или более ветвями на уровне фиксации.

Эта команда используется почти в каждой главе книги для демонстрации истории проекта.

Мы вводим команду и рассмотрим ее в некоторой глубине при просмотре истории фиксации. Там мы рассмотрим опцию `-pand--stat`, чтобы получить представление о том, что было введено в каждом коммите, `--pretty` и `--oneline` опции and для более краткого просмотра истории, а также некоторые простые параметры фильтрации даты и автора.

При создании новой ветви мы используем ее с `--decorate` возможностью легко визуализировать, где находятся наши указатели на ветви, а также использовать `--graph` возможность увидеть, как выглядят расходящиеся истории.

В Private Small Team и Commit Ranges мы рассмотрим branchA..branchB синтаксис использования git log команды, чтобы увидеть, какие коммиты уникальны для ветви относительно другой ветви. В диапазонах фиксации мы проходим через это довольно широко.

В журнале слияния и тройной точке мы используем `branch A…​branch` B формат и `--left-right` синтаксис, чтобы увидеть, что находится в одной или другой ветви, но не в обеих. В журнале слияний мы также рассмотрим, как использовать эту `--merge` опцию для отладки конфликтов слияний, а также `--cc` для просмотра конфликтов фиксации слияний в вашей истории.

В коротких именах RefLog мы используем `-g` возможность просмотра Git reflog через этот инструмент вместо обхода ветвей.

В поиске мы рассмотрим использование опций `-S` и `-L` для выполнения довольно сложных поисков чего-то, что произошло исторически в коде, например, просмотр истории функции.

В подписании коммитов мы видим, как использовать `--show-signature` для добавления строки проверки к каждому коммиту в git logвыводе на основе того, был ли он правильно подписан или нет.

**`git stash`**  
git stash Команда используется для временного хранения незафиксированной работы, чтобы очистить ваш рабочий каталог без необходимости фиксировать незавершенную работу в ветке.

## **Работа с удаленным репозиторием**

Команда `git remote` используется для выполнения удаленных подключений, таких как подключение локального репозитория Git к удаленному репозиторию GitHub.

**`Git remote`** — это просто соединение между локальным репозиторием и репозиторием GitHub. Через git remote мы предоставляем имя репозиторию, через которое мы можем ссылаться на репозиторий GitHub.

Другими словами, git remote можно рассматривать как ссылку на репозитории GitHub, которая не предоставляет никакого доступа в реальном времени к тому, что вы делаете локально, т. е. все, что вы делаете локально, не будет отражено в вашем репозитории GitHub без вашего разрешения.

Git remote можно использовать для подключения к вашему собственному репозиторию или для подключения к чужому репозиторию. Теперь давайте посмотрим, как связать существующий локальный репозиторий Git с удаленным репозиторием GitHub.

**`Git pull`** -команда скачивающая изменения с удаленного репозитория в локальный с одновременным слиянием элементов.

**`Git push`** - внесение изменений в удаленный репозиторий, требует авторизации.



