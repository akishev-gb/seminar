# Инструкция для работы с GIT

## Начальные настройки и установки

*git config --global user.name «Ваше имя английскими буквами» например: Konstantin*

*git config --global user.email ваша почта@example.com*

*git init* – **инициализация локального репозитория**

*git status* – **получить информацию от git о его текущем состоянии**

*git add* – **добавить файл или файлы к следующему коммиту**

*git commit -m “message”* – **создание коммита**.

*git log* – **вывод на экран истории всех коммитов с их хеш-кодами**

*git checkout* – **переход от одного коммита к другому**

*git checkout* master – **вернуться к актуальному состоянию и продолжить работу**

*git diff* – **увидеть разницу между текущим файлом и закоммиченным файлом**

## Работа с ветками

*git branch* – **посмотреть список веток в репозитории**

*git branch <название ветки>* – **создать новую ветку**

*git checkout <название ветки>* – **переход к другой ветке**

*git checkout -b <название ветки>* – **переход к новой созданной ветке**

*git branch -d <название ветки>* – **удалить ветку**

*git merge <branch_name>* - **слияние веток**

## Работа с удаленным репозиторием

*git clone* – **клонирование удаленного репозитория на локальный компьютер**

*git push* – **выгрузить изменения на удаленный репозиторий**

*git pull* – **стянуть изменения изи удаленного репозитория**

# Введение - Что такое GIT?

## Что такое GIT?

*Git* - **хранит и использует информацию совсем иначе по сравнению с другими системами, даже несмотря на то, что интерфейс пользователя достаточно похож, и понимание этих различий поможет вам избежать путаницы во время использования.**

## История

Разработка ядра Linux велась на проприетарной системе BitKeeper, которую автор — Ларри Маквой, сам разработчик Linux — предоставил проекту по бесплатной лицензии. Разработчики, высококлассные программисты, написали несколько утилит, и для одной Эндрю Триджелл произвёл реверс-инжиниринг формата передачи данных BitKeeper. В ответ Маквой обвинил разработчиков в нарушении соглашения и отозвал лицензию, и Торвальдс взялся за новую систему: ни одна из открытых систем не позволяла тысячам программистов кооперировать свои усилия (тот же конфликт привёл к написанию Mercurial). Идеология была проста: взять подход CVS и перевернуть с ног на голову, и заодно добавить надёжности. 

Начальная разработка велась меньше, чем неделю: 3 апреля 2005 года разработка началась, и уже 7 апреля код Git управлялся неготовой системой. 16 июня Linux был переведён на Git, а 25 июля Торвальдс отказался от обязанностей ведущего разработчика.

## Снимки, а не различия

*Основное отличие Git от любой другой СКВ (включая Subversion и её собратьев)* — **это подход к работе со своими данными. Концептуально, большинство других систем хранят информацию в виде списка изменений в файлах. Эти системы (CVS, Subversion, Perforce, Bazaar и т. д.) представляют хранимую информацию в виде набора файлов и изменений, сделанных в каждом файле, по времени (обычно это называют контролем версий, основанным на различиях).**

! [image] (https://git-scm.com/book/en/v2/images/deltas.png) - *Хранение данных как набора изменений относительно первоначальной версии каждого из файлов*

*Git не хранит и не обрабатывает данные таким способом.* **Вместо этого, подход Git к хранению данных больше похож на набор снимков миниатюрной файловой системы. Каждый раз, когда вы делаете коммит, то есть сохраняете состояние своего проекта в Git, система запоминает, как выглядит каждый файл в этот момент, и сохраняет ссылку на этот снимок. Для увеличения эффективности, если файлы не были изменены, Git не запоминает эти файлы вновь, а только создаёт ссылку на предыдущую версию идентичного файла, который уже сохранён. Git представляет свои данные как, скажем, поток снимков.**

! [image] (https://git-scm.com/book/en/v2/images/snapshots.png) - *Хранение данных как снимков проекта во времени*

Это очень важное отличие между Git и почти любой другой СКВ. Git переосмысливает практически все аспекты контроля версий, которые были скопированы из предыдущего поколения большинством других систем.

## Почти все операции выполняются локально

*Для работы большинства операций в Git достаточно локальных файлов и ресурсов* — **в основном, системе не нужна никакая информация с других компьютеров в вашей сети. Если вы привыкли к ЦСКВ, где большинство операций страдают от задержек из-за работы с сетью, то этот аспект Git заставит вас думать, что боги скорости наделили Git несказанной мощью. Так как вся история проекта хранится прямо на вашем локальном диске, большинство операций кажутся чуть ли не мгновенными.** 

*Для примера*, **чтобы посмотреть историю проекта, Git не нужно соединяться с сервером для её получения и отображения — система просто считывает данные напрямую из локальной базы данных. Это означает, что вы увидите историю проекта практически моментально. Если вам необходимо посмотреть изменения, сделанные между текущей версией файла и версией, созданной месяц назад, Git может найти файл месячной давности и локально вычислить изменения, вместо того, чтобы запрашивать удалённый сервер выполнить эту операцию, либо вместо получения старой версии файла с сервера и выполнения операции локально.**

## Целостность GIT

*В Git для всего вычисляется хеш-сумма, и только потом происходит сохранение.* **В дальнейшем обращение к сохранённым объектам происходит по этой хеш-сумме. Это значит, что невозможно изменить содержимое файла или каталога так, чтобы Git не узнал об этом. Данная функциональность встроена в Git на низком уровне и является неотъемлемой частью его философии. Вы не потеряете информацию во время её передачи и не получите повреждённый файл без ведома Git.** 

**Механизм, которым пользуется Git при вычислении хеш-сумм, называется SHA-1 хеш. Это строка длиной в 40 шестнадцатеричных символов (0-9 и a-f), она вычисляется на основе содержимого файла или структуры каталога. SHA-1 хеш выглядит примерно так:***<24b9da6552252987aa493b52f8696cd6d3b00373>*

**На самом деле, Git сохраняет все объекты в свою базу данных не по имени, а по хеш-сумме содержимого объекта.**

## Git обычно только добавляет данные.

**Когда вы производите какие-либо действия в Git, практически все из них только добавляют новые данные в базу Git. Очень сложно заставить систему удалить данные либо сделать что-то, что нельзя впоследствии отменить. Как и в любой другой СКВ, вы можете потерять или испортить свои изменения, пока они не зафиксированы, но после того, как вы зафиксируете снимок в Git, будет очень сложно что-либо потерять, особенно, если вы регулярно синхронизируете свою базу с другим репозиторием.** 

**Всё это превращает использование Git в одно удовольствие, потому что мы знаем, что можем экспериментировать, не боясь серьёзных проблем.**

## Три состояния

*У Git есть три основных состояния, в которых могут находиться ваши файлы:* **изменён (modified), *индексирован (staged) и зафиксирован (committed):**

*  *К изменённым относятся файлы, которые поменялись, но ещё не были зафиксированы.*

*  *Индексированный — это изменённый файл в его текущей версии, отмеченный для включения в следующий коммит.*

*  *Зафиксированный значит, что файл уже сохранён в вашей локальной базе.*

*Мы подошли к трём основным секциям проекта Git:* **рабочая копия (working tree), область индексирования (staging area) и каталог Git (Git directory).**

! [image] (https://git-scm.com/book/en/v2/images/areas.png) - *Рабочая копия, область индексирования и каталог Git*

*Рабочая копия является снимком одной версии проекта.* **Эти файлы извлекаются из сжатой базы данных в каталоге Git и помещаются на диск, для того чтобы их можно было использовать или редактировать.**

*Область индексирования* — **это файл, обычно находящийся в каталоге Git, в нём содержится информация о том, что попадёт в следующий коммит. Её техническое название на языке Git — «индекс», но фраза «область индексирования» также работает.**

*Каталог Git* — **это то место, где Git хранит метаданные и базу объектов вашего проекта. Это самая важная часть Git и это та часть, которая копируется при клонировании репозитория с другого компьютера.**

*Базовый подход в работе с Git выглядит так:*

1. *Изменяете файлы вашей рабочей копии.*

2. *Выборочно добавляете в индекс только те изменения, которые должны попасть в следующий коммит, добавляя тем самым снимки только этих изменений в индекс.*

3. *Когда вы делаете коммит, используются файлы из индекса как есть, и этот снимок сохраняется в ваш каталог Git.*

*Если определённая версия файла есть в каталоге Git, эта версия считается* **зафиксированной (committed)**. *Если файл был изменён и добавлен в индекс, значит,* **он индексирован (staged).** *И если файл был изменён с момента последнего распаковывания из репозитория, но не был добавлен в индекс,* **он считается изменённым (modified).**

# Ветвления в GIT

## Что такое ветка?

Дадим два определения ветки: на логическом и физическом уровнях.

1. Логический уровень.
С точки зрения логики, ветка – это последовательность коммитов. Чтобы проще было понять, что такое ветка, рассматривайте ее как некоторую временную шкалу. Коммиты в ней – снимки интересных моментов, идущие друг за другом в хронологической последовательности. Рисунок ниже поможет вам в интуитивном представлении.

![1_3](1_3.webp)

2. *Физический уровень*

 На физическом уровне, то есть с точки зрения внутренней реализации Git, ветка – это ссылка на последний коммит в этой ветке. Картинка ниже поможет вам понять, что к чему.

 ![Внутреннее представление веток Git. Ветки: main, develop, feature](2_3.png)

 Сравнивая рисунки, можно заметить, что ветка-ссылка указывает на коммит, который является последним в "потоке" коммитов в данной ветке. Таким образом, коммит С10 - последний сделанный коммит в ветке main, поэтому указатель main стоит над С10. То же самое можно сказать про develop – для этой ветки последним коммитом является С11, – и про feature, ее последним коммитом будет С7.

## Немного про указатели

 Указатель – это ссылка на определенный коммит или ветку. А ссылка – это некоторая метка, которую использует Git или сам пользователь, чтобы указать на коммит или ветку. И как мы уже сказали, физически ветки – самые настоящие указатели. Давайте приведем примеры еще некоторых часто используемых указателей: 
 
 1. HEAD – так называемый курсор Git. Главное назначение HEAD - определять, в каком состоянии находится рабочая копия (напомним, что рабочая копия – это все файлы репозитория, за исключением директории .git/). На какой коммит указывает HEAD – из того коммита и загружаются файлы в рабочую директорию. 
 
 2. ORIG_HEAD – указатель, который появляется, когда мы вручную передвигаем HEAD на какой-нибудь НЕ последний коммит. ORIG_HEAD указывает на тот же коммит, на который указывал HEAD до передвижения назад. Нужен он, чтобы мы имели возможность вернуться на хронологически последний коммит без существенных затрат (в истории мы не будем видеть все коммиты старше нашего, а поэтому не сможем узнать хэш последнего). 
 
 2. Пользовательские указатели. Пользователи сами могут создавать указатели. Например, вы можете создать указатель version-1.2.1, который будет указывать на коммит, в котором хранится версия 1.2.1 вашего проекта. Это довольно удобно, поскольку вы можете переключаться на коммит с той или иной версией, не запоминая его хэш.

## Зачем нужны ветки

1. Ветки нужны, чтобы несколько программистов могли вести работу над одним и тем же проектом или даже файлом одновременно, при этом не мешая друг другу. 

2. Кроме того, ветки используются для тестирования экспериментальных функций: чтобы не повредить основному проекту, создается новая ветка специально для экспериментов. Если эксперимент удался, изменения с экспериментальной ветки переносятся на основную, если нет – новая ветка попросту удаляется, а проект остается нетронутым. 

3. Помимо прочего, ветки можно использовать для разных выходящих параллельно релизов одного проекта. Например, в репозитории Python может быть две ветки: python-2 и python-3. До закрытия python-2 релизы этих версий языка выходили независимо друг от друга, поэтому могло иметь место такое разделение на ветки.

## Интересные факты от создателей GIT

* До GitHub у его сооснователей были провальные проекты. Они пытались делать Famspam — социальная сеть для того, чтобы «оставаться в контакте со своей семьей», с почтой и календарем для встреч. Она оказалась финансово полностью несостоятельной — ведь ее функции отлично дублировал Facebook. Уонстрат, выступая на MIT Startup Bootcamp, рассказывал, что за первые месяцы работы сети удалось заработать целых $12.

* GitHub, в свою очередь, уже через пару лет после запуска был прибыльным. «Мы больше не хотим, чтобы нас называли стартапом, ведь мы уже получаем прибыль… Мы взяли эту ужасную, неоригинальную, невдохновляющую идею и превратили ее в прибыльную компанию», — говорил Уонстрат в 2010 году — тогда сервис зарабатывал миллионы долларов в год

* Сервис основан на Git — свободно доступной системой управления версиями софта, созданной Линусом Торвальдсом для совместной работы над кодом в Linux. У Линуса есть профиль на GitHub, где в том числе хранится копия ядра Linux. Занятно, что еще в 2012 году легендарный разработчик объяснял, что не принимает пулл-реквесты (просто говоря — патчи или багфиксы, предложения по улучшению кода) на GitHub: платформа отлично подходит для хостинга, а вот для пулл-реквестов — не очень, мол, в оригинальном Git это работает лучше.

* Лого сервиса — легендарный octocat (помесь кота и осьминога, котосьминог, если пытаться перевести слово ближе к идее): это детище дизайнера Саймона Оуксли. Он же является автором первого логотипа Twitter.

![Twitter](https://techrocks.ru/wp-content/uploads/2018/04/twitter.png)

Создатели GitHub выкупили у него изображение из стока — и с тех пор, по словам дизайнера, он потерял над ним контроль. Существует огромное количество его вариантов — в стиле СуперМарио, Гомера Симпсона, My Little Pony и так далее.

![logo](https://techrocks.ru/wp-content/uploads/2018/04/github-logo.jpg)
