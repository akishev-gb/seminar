

![git-logo](git-logo.jpg)

# Инструкция по работе с системой контроля версий Git 

## Установка

* *Linux* — нужно просто открыть терминал и установить приложение при помощи пакетного менеджера вашего дистрибутива. Для Ubuntu команда будет выглядеть следующим образом:

    >sudo apt-get install git

* *Windows* — рекомендуется [git for windows](https://git-scm.com/download/win), так как он содержит и клиент с графическим интерфейсом, и эмулятор bash.

* *Mac*

Существует несколько способов установки Git на Mac. Самый простой — установить **Xcode Command Line Tools**. В версии Mavericks (10.9) и выше вы можете добиться этого просто первый раз выполнив 'git' в терминале.

Если Git не установлен, вам будет предложено его установить.Установщик Git для OS X доступен для скачивания с [с сайта Git](https://git-scm.com/download/mac).

## Настройка

После установки Git нужно добавить немного настроек. Сначала лучше настроить самые важные: **имя пользователя** и **адрес электронной почты**. Для этого необходимо открыть терминал и запустить команды:

>*git config --global user.name "Ваше имя английскими буквами"*

>*git config --global user.email myEmail@example.com*

Теперь каждое наше действие будет отмечено именем и почтой. Таким образом, пользователи всегда будут в курсе, кто отвечает за какие изменения — это вносит порядок.

Git хранит весь пакет конфигураций в файле .gitconfig, находящемся в вашем локальном каталоге. Чтобы сделать эти настройки глобальными, то есть применимыми ко всем проектам, необходимо добавить флаг –global. Если вы этого не сделаете, они будут распространяться только на текущий репозиторий.

Для того, чтобы посмотреть все настройки системы, используйте команду:

>*git config --list*

Если вы не до конца настроили систему перед тем, как начать работу – не волнуйстесь. Git всегда подскажет разработчику, если тот запутался, например:

1. Команда *git --help* **выводит общую документацию по Git.**
2. Если ввести *git log --help* **Git предоставит нам документацию по какой-то определенной команде (в данном случае это - log).**
3. **Если вы вдруг сделали опечатку - система подскажет вам нужную команду.**
4. **После выполнения любой команды - отчитается о том, что вы натворили.**
5. **Также Git прогнозирует дальнейшие варианты развития событий и всегда направит разработчика, не знающего, куда двигаться дальше.**

## Создание Git-репозитория

Обычно вы получаете репозиторий Git одним из двух способов:

1. можно взять **локальный каталог**, который в настоящее время не находится под версионным контролем, и превратить его в репозиторий Git;

2. можно **клонировать** существующий репозиторий Git из любого места.

### Создание репозитория в существующем каталоге

Если у вас **уже есть проект** в каталоге, который не находится под версионным контролем Git, то для начала **нужно перейти в него**. Для разных операционных систем это выглядит по-разному:

* для *Linux*:
    >*cd /home/user/my_project*

* для *macOS*:

    >*cd /Users/user/my_project*

* для *Windows*:

    >*cd C:/Users/user/my_project*

Затем выполняется команда:

>*git init*

На этом этапе проект ещё не находится под версионным контролем. Чтобы добавить под версионный контроль существующие файлы (в отличие от пустого каталога), нужно добавить их в индекс и осуществить первый коммит изменений. Добиться этого можно запустив команду **git add**, указав индексируемые файлы, а затем выполнив **git commit**:

>*git add <имя файла с расширением>*

>*git commit -m "Initial commit"*

### Клонирование существующего репозитория

Для получения копии существующего Git-репозитория, например, проекта, в который вы хотите внести свой вклад, необходимо использовать команду **git clone**.

>*git clone <url-адрес удаленного репозитория>*

Для выгрузки содержимого локального репозитория в удаленный репозиторий используется команда **git push**. Она позволяет передать коммиты из локального репозитория в удаленный. 

Для извлечения и загрузки содержимого из удаленного репозитория и немедленного обновления локального репозитория этим содержимым используется команда **git pull**. 

## Запись изменений в репозиторий

Каждый файл в рабочем каталоге может находиться в одном из двух состояний: под версионным контролем (**отслеживаемые**) и нет (**неотслеживаемые**). 

**Отслеживаемые файлы** — это те файлы, которые были в последнем снимке состояния проекта; они могут быть неизменёнными, изменёнными или подготовленными к коммиту. Если кратко, то отслеживаемые файлы — это **те файлы, о которых знает Git**.

**Неотслеживаемые файлы** — это всё остальное, любые файлы в вашем рабочем каталоге, которые не входили в ваш последний снимок состояния и не подготовлены к коммиту. Например, когда вы впервые клонируете репозиторий, все файлы будут отслеживаемыми и неизменёнными, потому что Git только что их извлек и вы ничего пока не редактировали.

Как только вы отредактируете файлы, Git будет рассматривать их как изменённые, так как вы изменили их с момента последнего коммита. Вы индексируете эти изменения, затем фиксируете все проиндексированные изменения, а затем цикл повторяется.

### Определение состояния файлов

Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда *git status*. Если выполнитm эту команду сразу после клонирования, можно увидеть что-то вроде этого:

>*git status*

>*On branch master*

>*Nothing to commit, working tree clean*

Это означает, что у вас чистый рабочий каталог, другими словами — в нем нет отслеживаемых измененных файлов. Git также не обнаружил неотслеживаемых файлов, в противном случае они бы были перечислены здесь.

### Отслеживание новых файлов

Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда **git add**. Чтобы начать отслеживание файла README, вы можете выполнить следующее:

>*git add README*

### Просмотр индексированных и неиндексированных изменений

Если результат работы команды **git status** покажется недостаточно информативным — например, нужно знать, что конкретно поменялось, а не только какие файлы были изменены — в этом случае можно использовать команду **git diff**. Если **git status** отвечает на эти вопросы в самом общем виде, перечисляя имена файлов, **git diff** показывает непосредственно добавленные и удалённые строки.

### Коммит изменений

Когда рабочий файл находится в таком состоянии, как вам и хотелось, можно зафиксировать изменения. 

Важно помнить, что **всё, что до сих пор не проиндексировано — любые файлы, созданные или изменённые, для которых не выполнялась комманда _git add_ после редактирования — не войдут в этот коммит**. 

Простейший способ зафиксировать изменения набрать следующее:

>*git commit -m "Text of our commit"*

### Просмотр истории коммитов

После того, как было создано несколько коммитов или же был клонирован репозиторий с уже существующей историей коммитов, пригодится возможность посмотреть что было сделано — историю коммитов. 

Одним из основных и наиболее мощных инструментов для этого является команда **git log**.

Если запустить команду **git log**, можно увидеть что-то подобное:

![git log](git-log.png)

По умолчанию **git log** перечисляет коммиты, сделанные в репозитории в обратном к хронологическому порядке — последние коммиты находятся вверху. 

Из примера можно увидеть, что данная команда перечисляет коммиты с их SHA-1 контрольными суммами, именем и электронной почтой автора, датой создания и сообщением коммита.

## Создание новой ветки и переход в неё

Создать новую ветку можно с помощью параметра **branch**, указав имя ветки:

>*git branch new_branch_name*

Но Git не переключится на неё автоматически. Для перехода нужно использовать параметр **checkout** и добавить имя ветки.

>*git checkout new_branch_name*

Можно просматривать полный список веток, используя параметр **branch**. Команда отобразит все ветки, отметит текущую звёздочкой (*) и выделит её цветом.

>*git branch*

## Удаление веток

Удалить ветку можно параметром **branch** с добавлением флага **-d** и указанием **имени ветки**. Если вы завершили работу над веткой и объединили её с основной, можно её удалить без потери истории. Однако, если выполнить команду удаления до слияния — в результате появится сообщение об ошибке. Этот защитный механизм предотвращает потерю доступа к файлам.

>*git branch -d existing_branch_name*

Для принудительного удаления ветки используется флаг **-D** с заглавной буквой. В этом случае ветка будет удалена независимо от текущего статуса, без предупреждений.

>*git branch -D existing_branch_name*

Вышеуказанные команды удаляют только локальную копию ветки. В удалённом репозитории она может сохраниться. Если хотите стереть удалённую ветку, выполните следующую команду:

>*git push origin --delete existing_branch_name*

## Слияние двух веток

Объединить две ветки можно параметром **merge** с указанием имени ветки. Команда объединит указанную ветку с основной.

>*git merge existing_branch_name*

Если надо выполнить коммит слияния, выполните команду **git merge** с флагом **--no-ff**.

>*git merge --no-ff existing_branch_name*

Указанная команда объединит заданную ветку с основной и произведёт коммит слияния. Это необходимо для фиксации всех слияний в вашем репозитории.

## Просмотр истории коммитов с визуализацией

Если к уже известной команде для просмотра истории коммитов **git log** добавить опцию **--graph**, то можно увидеть небольшой граф в формате ASCII, который показывает текущую ветку и историю слияний:

![История коммитов с визуализацией](log-graph.png)

## Краткий перечень упомянутых комманд

*git init* – **инициализирует пустой репозиторий**

*git status* – **выводит текущие изменений в файле**

*git add (имя файла либо ./ если нужно добавить все файлы* – **добавляет версионность файлу**

*git commit -m "Message"* – **создание и фиксация изменений**

*git log* – **выводит список изменений в хронологическом порядке**

*git diff* – **выводит разницу между предыдущим коммитом и текущими изменениями**

*git checkout (номер коммита или название ветки)* – **позволяет перемещаться между коммитами либо между ветками**

*git branch* – **выводит список всех созданных веток**

*git branch <branch_name>* – **создает ветку с именем branch_name**

*git checkout <branch_name>* – **переход на ветку branch_name**

*git branch -d <branch_name>* – **удаление ветки branch_name**

*git merge <branch_name>* – **слияние текущей ветки с веткой branch_name**

*git log --graph* – **вывод истории коммитов с визуализацией**

*git clone>* – **скачивание удаленного репозитория на локальную машину**

*git push* – **отправка или фиксация локальных изменений на удаленный репозиторий**

*git pull* – **скачивание изменений с удаленного репозитория на локальную машину**